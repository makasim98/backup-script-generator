#!/bin/bash

##### FOR TEMPLATES USED DURING SCRIPT GENERATION ONLY #####

generate_script_header() {
    
    local header=$(cat <<EOF
#!/bin/bash
#
# Backup Script generated by the Interactive Backup Script Generator
#
# This script performs a backup of the specified source paths, archives them,
# and automatically cleans up old backups to save space.

EOF
)
    echo "$header"
}

generate_script_configs() {
    local all_args=("$@")
    local num_sources=$((${#all_args[@]} - 3))
    local sources_arr=("${all_args[@]:0:num_sources}")
    local destination_path="${all_args[-3]}"
    local max_backups="${all_args[-2]}"
    local arch_format="${all_args[-1]}"

    case $arch_format in
        "tar")      arch_cmd="tar -cf"   ;;
        "tar.gz")   arch_cmd="tar -czf" ;;
        "zip")      arch_cmd="zip -r"   ;;
        *)
            echo "[\$(date)] Error: Unsupported archive format '\${ARCHIVE_FORMAT}'."
            exit 1
            ;;
    esac

    local config=$(cat <<EOF

# ----- Configuration -----
SOURCE_PATHS=(${sources_arr[@]})
DESTINATION_PATH="$destination_path"
MAX_BACKUPS="$max_backups"
ARCHIVE_FORMAT="$arch_format"
ARCHIVE_CMD="$arch_cmd"
TIMESTAMP=\$(date +%Y-%m-%d_%H-%M-%S)
BACKUP_FILENAME="backup-\${TIMESTAMP}.\${ARCHIVE_FORMAT}"
LOGFILE_PATH="\${DESTINATION_PATH}/backup.log"

# Redirect all output to logfile
exec &>> "\$LOGFILE_PATH"

EOF
)
    echo "$config"
}

generate_script_body() {
    local body=$(cat << EOF

# ----- Perform the Backup -----
# Create destination directory if it doesn't exist
mkdir -p "\${DESTINATION_PATH}"

echo "====================================================================================="
echo "[\$(date)] Archiving files to \${BACKUP_FILENAME}..." | tee /dev/tty
\${ARCHIVE_CMD} "\${DESTINATION_PATH}/\${BACKUP_FILENAME}" "\${SOURCE_PATHS[@]}"
if [ \$? -ne 0 ] ; then
    echo "[\$(date)] ERROR: Backup failed. See logs at destination path for details"
    exit 1
fi
echo "[\$(date)] Backup successful." | tee /dev/tty

# Clen-up old backups, keeping only a certain amount of newest ones
echo "[\$(date)] Cleaning old backups (keeping \${MAX_BACKUPS} most recent)..."
ls -t \${DESTINATION_PATH}/backup-*.\${ARCHIVE_FORMAT} | tail -n +\$((MAX_BACKUPS + 1)) | xargs rm -f 
if [ \$? -eq 0 ]; then
    echo "[\$(date)] Cleanup complete."
else
    echo "[\$(date)] Cleaning failed."
fi

echo "[\$(date)] Backup script finished." | tee /dev/tty
exit 0

EOF
)
    echo "$body"
}